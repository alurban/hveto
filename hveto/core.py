# -*- coding: utf-8 -*-
# Copyright (C) Joshua Smith (2016-)
#
# This file is part of the hveto python package.
#
# hveto is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# hveto is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with hveto.  If not, see <http://www.gnu.org/licenses/>.

"""Core of the HierarchichalVeto algorithm
"""

from math import (log, exp, log10)

import numpy

from scipy.special import (gammainc, gammaln)

from gwpy.segments import (SegmentList, Segment)

from . import version

__version__ = version.version
__author__ = 'Duncan Macleod <duncan.macleod@ligo.org>'
__credits__ = 'Joshua Smith <joshua.smith@ligo.org>'


# -- define round structure --------------------------------------------------

class HvetoRound(object):
    __slots__ = (
        'n',
        'winner',
        'segments',
        'vetoes',
        'use_percentage',
        'efficiency',
        'cum_efficiency',
        'cum_deadtime',
        'plots',
    )

    def __init__(self, round, segments=None, vetoes=None, plots=[]):
        self.n = round
        self.segments = segments
        self.vetoes = vetoes
        self.plots = []

    @property
    def livetime(self):
        return float(abs(self.segments))

    @property
    def deadtime(self):
        return (float(abs((self.vetoes & self.segments).coalesce())),
                float(abs(self.segments)))


# -- core methods ------------------------------------------------------------

def find_max_significance(primary, auxiliary, channel,
                          snrs, windows, livetime):
    """Find the maximum Hveto significance for this primary-auxiliary pair

    Parameters
    ----------
    primary : `numpy.recarray`
        record array of data from the primary channel
    auxiliary : `numpy.recarray`
        record array from the auxiliary channel
    snrs : `list` of `float`
        the SNR thresholds to use
    window : `list` of `float`
        the time windows to use

    Returns
    -------
    winner : `HvetoWinner`
        the parameters and segments generated by the (snr, dt) with the
        highest significance
    """
    winner = HvetoWinner(name=channel, significance=0)
    if isinstance(primary, numpy.recarray):
        primary = primary['time']
    for snr in snrs:
        b = auxiliary[auxiliary['snr'] >= snr]
        for dt in windows:
            _, sig = hveto_significance(
               primary, b['time'], dt=dt, livetime=livetime)
            if sig > winner.significance:
                winner.significance = sig
                winner.snr = snr
                winner.window = dt
    return winner


class HvetoWinner(object):
    __slots__ = ['name', 'significance', 'snr', 'window', 'segments',
                 'events', 'ncoinc']

    def __init__(self, name=None, significance=None, snr=None,
                 window=None, segments=None, events=None, ncoinc=0):
        super(HvetoWinner, self).__init__()
        self.name = name
        self.significance = significance
        self.snr = snr
        self.window = window
        self.segments = segments
        self.events = events

    def get_segments(self, times):
        return SegmentList([Segment(t - self.window/2., t + self.window/2.)
                            for t in times])


def hveto_significance(a, b, dt, livetime):
    """Calculate the significance of coincidences between two time arrays

    Parameters
    ----------
    a : `numpy.ndarray`
        first array
    b : `numpy.ndarray`
        second array
    dt : `float`
        coincidence window
    livetime : `float`
        the livetime of the analysis

    Returns
    -------
    coincs : `numpy.ndarray`
        the indices of array `a` that were coincident with an entry in `b`
    significance : `float`
        the Poisson significance of the number of coincidences found as
        compared to the number expected by random chance
    """
    # find coincidences
    coincs = find_coincidences(a, b, dt=dt)
    n = coincs.size
    if n == 0:
        return coincs, 0
    # calculate significance
    try:
        prob = a.size * dt / livetime
    except ZeroDivisionError:
        prob = 0
    mu = prob * b.size
    g = gammainc(n, mu)
    if g == 0:
        sig = -n * log10(mu) + log10(exp(1)) + gammaln(n+1) / log(10)
    else:
        sig = -log(g, 10)
    return coincs, sig


def find_coincidences(a, b, dt=1):
    """Find the coincidences between values in two numpy arrays

    Parameters
    ----------
    a : `numpy.ndarray`
        first array
    b : `numpy.ndarray`
        second array
    dt : `float`, optional
        coincidence window

    Returns
    -------
    coinc : `numpy.ndarray`
        the indices of all items in `a` within [-dt/2., +dt/2.) of an item
        in `b`
    """
    def _is_coincident(t):
        return (numpy.abs(b - t) <= dt/2.).any()
    is_coincident = numpy.vectorize(_is_coincident)
    return is_coincident(a).nonzero()[0]


def veto(table, segmentlist):
    """Remove events from a table based on a segmentlist
    """
    times = table['time']
    def _not_vetoed(t):
        return t not in segmentlist
    try:
        keep = numpy.vectorize(_not_vetoed)(table['time'])
    except IndexError:  # empty table
        return table, table
    return table[keep], table[~keep]


def count_used(table, segmentlist):
    """Calculate the number of segments overlapping a set of times
    """
    use = 0
    for seg in segmentlist:
        if veto(table, type(segmentlist)([seg]))[1].size:
            use += 1
    return use
